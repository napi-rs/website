---
title: 'Getting started'
description: Learn how to get started with napi-rs.
---

# Getting started

import { GuideVideo } from '../../../components/guide-video'

## Start from `@napi-rs/cli`

> The recommend way.

<br />

<GuideVideo />

### Install cli

```bash
yarn global add @napi-rs/cli
# or
npm install -g @napi-rs/cli
# or
pnpm add -g @napi-rs/cli
```

### Create project

```bash
napi new
```

#### Package name

The name filed in `package.json`.

#### Choose targets you want to support

Platforms you want support to.

#### Enable GitHub actions

Generate GitHub actions config for you.

### Deep dive

Here it is recommended to distribute your package under [npm scope](https://docs.npmjs.com/creating-and-publishing-scoped-public-packages/) because `@napi-rs/cli` by default appends the different platform suffixes to the npm package name as the package name for the different platform binary distribution. Using npm scope will reduce the case of package name was taken.

For example if you want publish package `@cool/core`, with the `macOS x64`, `Windows x64` and `Linux aarch64` supported, `@napi-rs/cli` will create and publish four package for you:

- `@cool/core` includes just `JavaScript` codes, which actually load the native binary from per platforms.
- `@cool/core-darwin-x64` for `macOS x64` platform.
- `@cool/core-win32-x64` for `Windows x64` platform.
- `@cool/core-linux-arm64-gnu` for `Linux aarch64` platform.

In every platform binary package, there are `cpu` and `os` fields in there `package.json`:

```json filename="package.json"
{
  "name": "@cool/core-darwin-x64",
  "version": "1.0.0",
  "os": ["darwin"],
  "cpu": ["x64"]
}
```

And `@cool/core` using these native packages as `optionalDependencies`:

```json filename="package.json"
{
  "name": "@cool/core",
  "version": "1.0.0",
  "optionalDependencies": {
    "@cool/core-darwin-x64": "^1.0.0",
    "@cool/core-win32-x64": "^1.0.0",
    "@cool/core-linux-arm64": "^1.0.0"
  }
}
```

And your `index.js` in `@cool/core` will be this:

```js filename="index.js"
const { existsSync, readFileSync } = require('fs')
const { join } = require('path')

const { platform, arch } = process

let nativeBinding = null
let localFileExisted = false
let isMusl = false
let loadError = null

switch (platform) {
  case 'darwin':
    switch (arch) {
      case 'x64':
        localFileExisted = existsSync(join(__dirname, 'core.darwin-x64.node'))
        try {
          if (localFileExisted) {
            nativeBinding = require('./core.darwin-x64.node')
          } else {
            nativeBinding = require('@cool/core-darwin-x64')
          }
        } catch (e) {
          loadError = e
        }
        break
      case 'arm64':
        localFileExisted = existsSync(join(__dirname, 'core.darwin-arm64.node'))
        try {
          if (localFileExisted) {
            nativeBinding = require('./core.darwin-arm64.node')
          } else {
            nativeBinding = require('@cool/core-darwin-arm64')
          }
        } catch (e) {
          loadError = e
        }
        break
      default:
        throw new Error(`Unsupported architecture on macOS: ${arch}`)
    }
    break
  // ...
  default:
    throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`)
}

if (!nativeBinding) {
  if (loadError) {
    throw loadError
  }
  throw new Error(`Failed to load native binding`)
}

const { plus100 } = nativeBinding

module.exports.plus100 = plus100
```

The generated `index.js` file will help you to load the **_right_** binary file wherever you are. And the `index.js` handle two cases:

#### Package installed in users `node_modules`

{/* 为了加载正确二进制文件，`index.js` 函数会尝试加载该平台下所有可能的包(在给定系统和 CPU 架构下可能存在多种可能的二进制包)，比如在 `Linux x64` 平台，`index.js` 会尝试加载 `@cool/core-linux-x64-gnu` 和 `@cool/core-linux-x64-musl`。 如果用户使用的是 `Ubuntu` `Debian` 等预装 `gnu libc` 的操作系统，则 `@cool/core-linux-x64-gnu` 这个包会被加载进来。而如果用户使用的是 `Alpine` 这种预装 `musl libc` 的操作系统，则 `@cool/core-linux-x64-musl` 会被加载进来。 */}

To load the correct binary, the `index.js` function tries to load all possible packages for that platform (there may be multiple possible binary packages for a given system and CPU architecture), for example, on the `Linux x64` platform, `index.js` tries to load `@cool/core-linux-x64-gnu` and `@cool/core-linux-x64-musl`. The package `@cool/core-linux-x64-gnu` will be loaded if the user is using an operating system like `Ubuntu` `Debian` with `gnu libc` pre-installed. And if the user is using an operating system like `Alpine` with `musl libc` pre-installed, then `@cool/core-linux-x64-musl` will be loaded.

#### Local development

{/* `@napi-rs/cli` new 命令生成的项目中，package.json 中的 `build` 命令会将 `Rust` 代码编译出来的二进制动态链接库生成到当前目录下，以方便调试。`index.js` 在这种情况下也会尝试从当前目录中加载相应的二进制文件。还是以 `Linux x64` 为例，`index.js` 函数会依次尝试加载 `core.linux-x64-gnu.node` 和 `core.linux-x64-musl.node` 文件。 */}

The `build` command in package.json in the project generated by the `@napi-rs/cli` new command will generate the binary dynamic link library compiled from the `Rust` code into the current directory for debugging purposes. `index.js` will also try to load the corresponding binary from the current directory in this case. Again using `Linux x64` as an example, the `index.js` function will try to load the `core.linux-x64-gnu.node` and `core.linux-x64-musl.node` files in turn.

## Start from [GitHub template project](https://github.com/napi-rs/package-template)

![package-template](./package-template.png)

1. Go to [GitHub template project](https://github.com/napi-rs/package-template)
2. **Click Use this template**.
3. Clone your project.
4. Run `yarn install` to install dependencies.
5. Run `npx napi rename` command under the project folder to rename your package.
